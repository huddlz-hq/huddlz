# Contract: register_with_password Action

## Action Details

**Resource**: `Huddlz.Accounts.User`
**Action**: `register_with_password` (auto-generated by AshAuthentication)
**Type**: Create
**Authentication Strategy**: Password (AshAuthentication)

## Purpose

Registers a new user with email/password authentication, including a required display name.

## Request Contract

### Input Parameters

```elixir
%{
  "email" => String.t(),                    # Required, valid email format
  "password" => String.t(),                 # Required, min 8 characters
  "password_confirmation" => String.t(),    # Required, must match password
  "display_name" => String.t()              # Required (NEW), 1-70 characters
}
```

### Validation Rules

**email**:
- Required
- Must be valid email format
- Case-insensitive comparison
- Must not already exist (uniqueness check)

**password**:
- Required
- Minimum 8 characters
- Hashed using bcrypt before storage

**password_confirmation**:
- Required
- Must exactly match password

**display_name** (NEW):
- Required (cannot be nil or empty string)
- Minimum length: 1 character
- Maximum length: 70 characters
- Character set: All printable UTF-8 characters (letters, numbers, spaces, punctuation, emojis)
- No uniqueness constraint (duplicates allowed)

### Example Valid Requests

```elixir
# Standard name
%{
  "email" => "john@example.com",
  "password" => "securepass123",
  "password_confirmation" => "securepass123",
  "display_name" => "John Doe"
}

# Single name
%{
  "email" => "madonna@example.com",
  "password" => "securepass123",
  "password_confirmation" => "securepass123",
  "display_name" => "Madonna"
}

# With emoji
%{
  "email" => "sam@example.com",
  "password" => "securepass123",
  "password_confirmation" => "securepass123",
  "display_name" => "Sam ðŸŽ‰"
}

# Accented characters
%{
  "email" => "jose@example.com",
  "password" => "securepass123",
  "password_confirmation" => "securepass123",
  "display_name" => "JosÃ© GarcÃ­a"
}

# Maximum length (70 characters)
%{
  "email" => "long@example.com",
  "password" => "securepass123",
  "password_confirmation" => "securepass123",
  "display_name" => String.duplicate("A", 70)
}
```

## Response Contract

### Success Response

**Status**: `{:ok, user}`

```elixir
{:ok, %Huddlz.Accounts.User{
  id: "550e8400-e29b-41d4-a716-446655440000",  # UUID
  email: "john@example.com",
  display_name: "John Doe",                    # Stored display name
  role: :user,                                  # Default role
  confirmed_at: nil,                            # Pending email confirmation
  hashed_password: "$2b$12$...",               # Bcrypt hash
  inserted_at: ~U[2025-10-01 12:00:00Z],
  updated_at: ~U[2025-10-01 12:00:00Z]
}}
```

### Error Responses

#### Missing Display Name

```elixir
{:error, %Ash.Error.Invalid{
  errors: [
    %Ash.Error.Changes.InvalidAttribute{
      field: :display_name,
      message: "must be present",
      value: nil
    }
  ]
}}
```

#### Display Name Too Long

```elixir
{:error, %Ash.Error.Invalid{
  errors: [
    %Ash.Error.Changes.InvalidAttribute{
      field: :display_name,
      message: "length must be less than or equal to 70",
      value: "Very long name that exceeds the maximum allowed length..."
    }
  ]
}}
```

#### Empty Display Name

```elixir
{:error, %Ash.Error.Invalid{
  errors: [
    %Ash.Error.Changes.InvalidAttribute{
      field: :display_name,
      message: "must not be empty",
      value: ""
    }
  ]
}}
```

#### Email Already Exists (existing validation)

```elixir
{:error, %Ash.Error.Invalid{
  errors: [
    %Ash.Error.Changes.InvalidAttribute{
      field: :email,
      message: "has already been taken",
      value: "existing@example.com"
    }
  ]
}}
```

#### Password Too Short (existing validation)

```elixir
{:error, %Ash.Error.Invalid{
  errors: [
    %Ash.Error.Changes.InvalidAttribute{
      field: :password,
      message: "length must be greater than or equal to 8",
      value: "short"
    }
  ]
}}
```

#### Passwords Don't Match (existing validation)

```elixir
{:error, %Ash.Error.Invalid{
  errors: [
    %Ash.Error.Changes.InvalidAttribute{
      field: :password_confirmation,
      message: "does not match password",
      value: "mismatch"
    }
  ]
}}
```

## Behavioral Contracts

### Pre-conditions

- User is not authenticated (anonymous request)
- Email is not already registered
- Password meets security requirements
- Display name meets validation requirements

### Post-conditions

- New user record created in database
- Password is hashed and stored securely
- Display name is stored exactly as entered (no transformation)
- User is in unconfirmed state (confirmed_at is nil)
- Confirmation email sent (separate concern)

### Side Effects

1. Database write: INSERT into users table
2. Token generation: Create authentication tokens
3. Email dispatch: Send confirmation email (via AshAuthentication add-on)

### Idempotency

NOT idempotent. Multiple calls with same data will fail on second attempt due to email uniqueness constraint.

## Test Contract

### Required Test Cases

#### Happy Path Tests

```elixir
test "registers user with valid display_name" do
  assert {:ok, user} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "test@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: "Test User"
    })
    |> Ash.create()

  assert user.display_name == "Test User"
  assert user.email == "test@example.com"
end

test "accepts single-name display_name" do
  assert {:ok, user} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "madonna@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: "Madonna"
    })
    |> Ash.create()

  assert user.display_name == "Madonna"
end

test "accepts display_name with emoji" do
  assert {:ok, user} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "emoji@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: "Sam ðŸŽ‰"
    })
    |> Ash.create()

  assert user.display_name == "Sam ðŸŽ‰"
end

test "accepts display_name with accented characters" do
  assert {:ok, user} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "jose@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: "JosÃ© GarcÃ­a"
    })
    |> Ash.create()

  assert user.display_name == "JosÃ© GarcÃ­a"
end

test "accepts display_name at maximum length (70 chars)" do
  long_name = String.duplicate("A", 70)

  assert {:ok, user} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "long@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: long_name
    })
    |> Ash.create()

  assert user.display_name == long_name
end
```

#### Validation Failure Tests

```elixir
test "rejects registration without display_name" do
  assert {:error, %Ash.Error.Invalid{} = error} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "test@example.com",
      password: "password123",
      password_confirmation: "password123"
      # display_name missing
    })
    |> Ash.create()

  assert "must be present" in error.errors |> Enum.map(& &1.message)
end

test "rejects registration with empty display_name" do
  assert {:error, %Ash.Error.Invalid{}} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "test@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: ""
    })
    |> Ash.create()
end

test "rejects display_name over 70 characters" do
  long_name = String.duplicate("A", 71)

  assert {:error, %Ash.Error.Invalid{}} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "test@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: long_name
    })
    |> Ash.create()
end
```

#### Edge Case Tests

```elixir
test "allows duplicate display_names" do
  # Create first user
  {:ok, _user1} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "user1@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: "John Doe"
    })
    |> Ash.create()

  # Create second user with same display_name
  assert {:ok, user2} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "user2@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: "John Doe"  # Same as user1
    })
    |> Ash.create()

  assert user2.display_name == "John Doe"
end

test "accepts display_name with only special characters" do
  assert {:ok, user} =
    User
    |> Ash.Changeset.for_create(:register_with_password, %{
      email: "special@example.com",
      password: "password123",
      password_confirmation: "password123",
      display_name: "!@#$%"
    })
    |> Ash.create()

  assert user.display_name == "!@#$%"
end
```

## Integration Points

### AshAuthentication

This action is auto-generated by the password strategy. The action signature is:
```elixir
strategies do
  password :password do
    identity_field :email
    hash_provider AshAuthentication.BcryptProvider
  end
end
```

The display_name field is automatically included because it's a required attribute on the User resource.

### Phoenix LiveView

The Register LiveView form submits to this action via AshPhoenix.Form:
```elixir
form =
  User
  |> Form.for_create(:register_with_password, as: "user")
```

Form fields map directly to action parameters.

## Changes from Previous Version

**Before**:
- display_name was optional (allow_nil? true)
- display_name max length was 30 characters
- display_name not included in registration form

**After**:
- display_name is required (allow_nil? false)
- display_name max length is 70 characters
- display_name must be provided during registration

## Migration Compatibility

Existing users (created before this change) will have display_name backfilled from their email address during migration. New registrations must provide display_name.
