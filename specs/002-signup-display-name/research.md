# Research: Signup Display Name

## Overview
Research findings for implementing display name field on signup with proper validation and visibility across the platform.

## 1. Current User Resource Structure

**Decision**: Modify existing User resource in `lib/huddlz/accounts/user.ex`

**Current Implementation Analysis**:
```elixir
attribute :display_name, :string do
  description "Name the user wants others to identify them as"
  allow_nil? true
  public? true
  constraints min_length: 1, max_length: 30
end

update :update_display_name do
  description "Update a user's display_name"
  accept [:display_name]
  validate attribute_does_not_equal(:display_name, "")
  validate string_length(:display_name, min: 1, max: 30)
end
```

**Required Changes**:
- Change `allow_nil? true` to `allow_nil? false` (make required)
- Change `max_length: 30` to `max_length: 70` in attribute constraints
- Update `update_display_name` action validation from `max: 30` to `max: 70`
- Verify `SetDefaultDisplayName` change handles required field properly

**Rationale**:
- Spec requires 70 character maximum (increased from 30)
- Spec requires display_name to be mandatory (no empty values)
- All printable characters including emojis already supported by string type
- Non-uniqueness already supported (no unique constraint exists)

**Alternatives Considered**:
- Creating new attribute: Rejected - attribute already exists with correct purpose
- Adding character validation: Rejected - Elixir strings handle all UTF-8 including emojis by default

## 2. Signup Form Integration

**Decision**: Update `lib/huddlz_web/live/auth_live/register.ex` to include display_name field

**Current Implementation**:
- Form uses `register_with_password` action from AshAuthentication
- Only includes email and password fields
- Uses standard `<.input>` component from core_components.ex

**Implementation Approach**:
```elixir
<.input
  field={@form[:display_name]}
  type="text"
  label="Display Name"
  placeholder="First and Last Name"
  required
  autocomplete="name"
/>
```

**Form Validation**:
- AshPhoenix.Form automatically validates based on resource constraints
- Changeset errors will be displayed by `<.input>` component
- Client-side validation via HTML5 `required` attribute
- Server-side validation via Ash resource constraints

**Rationale**:
- Reuse existing input component for consistency
- Leverage Ash's built-in validation system
- Standard LiveView form patterns

**Alternatives Considered**:
- Custom input component: Rejected - existing component handles all requirements
- JavaScript validation: Rejected - HTML5 + server-side sufficient

## 3. AshAuthentication Integration

**Decision**: Modify `register_with_password` strategy to accept display_name

**AshAuthentication Strategy Pattern**:
```elixir
strategies do
  password :password do
    identity_field :email
    # Strategy automatically generates register_with_password action
  end
end
```

**Implementation Approach**:
The `register_with_password` action is auto-generated by AshAuthentication. To add display_name:

1. **Option A**: Let AshAuthentication handle it automatically
   - If display_name has `allow_nil? false`, it becomes required
   - AshAuthentication actions respect resource attribute constraints
   - No explicit configuration needed

2. **Option B**: Customize the registration action
   - Add explicit `accept` list to include display_name
   - Add custom changes or validations if needed

**Selected Approach**: Option A (automatic)
- Simpler, follows framework conventions
- Resource constraints drive behavior
- Less code to maintain

**Rationale**:
- AshAuthentication is designed to work with resource attributes
- Making attribute required is sufficient to make it required in registration
- Framework handles the plumbing automatically

**Alternatives Considered**:
- Manual registration action: Rejected - AshAuthentication provides better security defaults
- Separate display_name update after signup: Rejected - creates incomplete user records

## 4. Database Migration Strategy

**Decision**: Use Ash migration generation for schema changes

**Migration Process**:
1. Update User resource attributes (max_length and allow_nil)
2. Run `mix ash.codegen update_user_display_name_constraints`
3. Review generated migration in `priv/repo/migrations/`
4. Run `mix ash.migrate` (or `mix ash.setup` in dev)

**Expected Migration**:
```elixir
alter table(:users) do
  modify :display_name, :text, null: false
  # Note: String length constraints are application-level, not DB-level in Ash
end
```

**Handling Existing Data**:
- Current users may have null display_name values
- Migration needs a default or data backfill strategy
- Options:
  1. Set default value during migration (e.g., "User")
  2. Backfill from email (take part before @)
  3. Leave null for existing, require for new (but spec says required)

**Selected Approach**: Set temporary default during migration
- Generate display name from email for existing users
- Use custom migration task if needed
- Example: `user123@example.com` â†’ `user123`

**Rationale**:
- Spec requires display_name to be mandatory
- Existing users need valid values
- Email-based default is reasonable fallback
- Users can change it later via update_display_name action

**Alternatives Considered**:
- Manual SQL migration: Rejected - violates constitutional requirement
- Allow null for existing users: Rejected - creates inconsistent validation
- Prompt users on next login: Deferred - UX consideration for later

## 5. Display Name Visibility

**Decision**: No code changes needed - attribute already public

**Current State**:
- User resource has `public? true` on display_name attribute
- Attribute included in default reads
- Available to all views and components via user struct

**Implementation Verification**:
Need to verify display_name is shown in:
- User profile pages
- Huddl attendee lists
- Comments/posts (if applicable)
- Any other user references

**Approach**:
- Audit existing views that render user information
- Ensure `user.display_name` is displayed instead of email
- Update templates during implementation phase

**Rationale**:
- Spec requires display name shown everywhere user is referenced
- This is a presentation concern, not a resource concern
- Verification happens during implementation, not planning

**Alternatives Considered**:
- Add computed field: Rejected - display_name already exists
- Add GraphQL-specific fields: Deferred - only if GraphQL endpoints are added

## 6. Testing Strategy

**Decision**: Multi-layer testing approach following Ash patterns

**Test Layers**:

1. **Resource Action Tests** (`test/huddlz/accounts/user_test.exs`)
   - Test display_name required on create
   - Test max_length validation (70 characters)
   - Test min_length validation (1 character)
   - Test special characters and emojis accepted
   - Test update_display_name action with new constraints

2. **Permission Tests** (same file)
   - Test users can update their own display_name
   - Test users cannot update others' display_name
   - Test unauthorized update attempts fail

3. **LiveView Tests** (`test/huddlz_web/live/auth_live/register_test.exs`)
   - Test display_name field present on form
   - Test form submission with valid display_name
   - Test form submission with empty display_name (should fail)
   - Test form submission with too long display_name (should fail)
   - Test placeholder text shown

4. **Integration Tests**
   - Full signup flow with display_name
   - Verify created user has display_name saved
   - Verify display_name appears in user profile

**Test Data Examples**:
```elixir
# Valid cases
"John Doe"           # Standard name
"Madonna"            # Single name
"JosÃ© GarcÃ­a"        # Accented characters
"Sam ðŸŽ‰"             # With emoji
"A"                  # Minimum length (1 char)
String.duplicate("A", 70)  # Maximum length

# Invalid cases
""                   # Empty string
nil                  # Null value
String.duplicate("A", 71)  # Over maximum
```

**Rationale**:
- Constitutional requirement: comprehensive action and permission testing
- Test-after-resource pattern: write tests after resource changes, before UI
- Ash provides test helpers for clean action testing

**Alternatives Considered**:
- Property-based testing: Deferred - add later if needed
- E2E browser tests: Deferred - integration tests provide sufficient coverage

## 7. Performance Considerations

**Decision**: No special performance optimizations needed

**Analysis**:
- Display name is a simple string attribute
- Indexed email lookup already exists (may be used for default generation)
- No N+1 queries concern - display_name loaded with user
- Character length validation is O(1) in Elixir

**Monitoring**:
- Standard Ash query performance monitoring
- No special indexes needed (display_name not searchable per spec)

**Rationale**:
- Simple attribute addition has negligible performance impact
- Validation overhead is minimal
- No database query changes beyond schema update

**Alternatives Considered**:
- Add GIN index for search: Rejected - spec doesn't require display name search
- Normalize display names: Rejected - spec allows all characters as-is

## Summary

All technical decisions are clear and implementation-ready:

1. âœ… Modify existing User resource constraints (max 70, required)
2. âœ… Update register form to include display_name field
3. âœ… Generate Ash migration for constraint changes
4. âœ… Backfill existing users with email-based defaults
5. âœ… Write comprehensive tests following constitutional pattern
6. âœ… Verify display visibility during implementation

No blocking unknowns remain. Ready to proceed to Phase 1 (Design & Contracts).
